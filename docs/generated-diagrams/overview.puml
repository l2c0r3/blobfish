@startuml

class ch.hslu.cas.msed.blobfish.Main {
	{method}  {static} ~main () : void
}


class ch.hslu.cas.msed.blobfish.base.FenUtil {
	{method}  {static} +getFenPositionBlocks ( paramString1 : String ) : [Ljava.lang.String;
	{method}  {static} +validateFenString ( paramString1 : String ) : void
}


class ch.hslu.cas.msed.blobfish.base.Piece {
	{method} +color () : ch.hslu.cas.msed.blobfish.base.PlayerColor
	{method} +equals ( paramObject1 : Object ) : boolean
	{method} +fen () : Character
	{method} +hashCode () : int
	{method} +materialPoints () : int
	{method} +toString () : String
	{method} +type () : ch.hslu.cas.msed.blobfish.base.PieceType
}


enum ch.hslu.cas.msed.blobfish.base.PieceType {
	{field} +BISHOP
	{field} +KING
	{field} +KNIGHT
	{field} +PAWN
	{field} +QUEEN
	{field} +ROOK
}


enum ch.hslu.cas.msed.blobfish.base.PlayerColor {
	{field} +BLACK
	{field} +WHITE
}


class ch.hslu.cas.msed.blobfish.board.ChessBoard {
	{field} {static} -STARTPOSITION_FEN : String
	{field} -board : com.github.bhlangonijr.chesslib.Board
	{method} +doMove ( paramString1 : String ) : ch.hslu.cas.msed.blobfish.board.ChessBoard
	{method} +getFen () : String
	{method} +isGameOver () : boolean
	{method} +isMoveLegal ( paramString1 : String ) : boolean
	{method} +legalMoves () : java.util.List
}


class ch.hslu.cas.msed.blobfish.board.ui.BoardRenderer {
	{method} ~render ( paramUiBoard1 : ch.hslu.cas.msed.blobfish.board.ui.UiBoard , paramPlayerColor2 : ch.hslu.cas.msed.blobfish.base.PlayerColor ) : String
}


class ch.hslu.cas.msed.blobfish.board.ui.ChessBoardRenderer {
	{field} -parser : ch.hslu.cas.msed.blobfish.board.ui.FenUiBoardParser
	{method} +render ( paramString1 : String , paramPlayerColor2 : ch.hslu.cas.msed.blobfish.base.PlayerColor ) : String
}


interface ch.hslu.cas.msed.blobfish.board.ui.FieldRenderer {
	{method}  {abstract} +render ( paramUiField1 : ch.hslu.cas.msed.blobfish.board.ui.UiField ) : String
}


enum ch.hslu.cas.msed.blobfish.board.ui.SquareColor {
	{field} +DARK
	{field} +LIGHT
}


interface ch.hslu.cas.msed.blobfish.eval.EvalStrategy {
	{method}  {abstract} +getEvaluation ( paramString1 : String ) : double
}


class ch.hslu.cas.msed.blobfish.eval.MateAwareEval {
	{field} {static} -MAX_NUMBER : double
	{method} +getEvaluation ( paramString1 : String ) : double
}


class ch.hslu.cas.msed.blobfish.eval.MaterialEval {
	{method} +getEvaluation ( paramString1 : String ) : double
	{method} -parseFen ( paramString1 : String ) : java.util.List
	{method} -removeEmptyFieldsFromPosition ( paramString1 : String ) : String
}


class ch.hslu.cas.msed.blobfish.eval.RandomEval {
	{method} +getEvaluation ( paramString1 : String ) : double
}


class ch.hslu.cas.msed.blobfish.game.ChessGame {
	{field} -terminal : org.jline.terminal.Terminal
	{method} -shouldRestart ( paramInputReader1 : ch.hslu.cas.msed.blobfish.game.InputReader , paramOutputWriter2 : ch.hslu.cas.msed.blobfish.game.OutputWriter ) : boolean
	{method} +start () : void
	{method} -writeEndGameMessage ( paramOutputWriter1 : ch.hslu.cas.msed.blobfish.game.OutputWriter ) : void
}


class ch.hslu.cas.msed.blobfish.game.InputReader {
	{field} -reader : org.jline.reader.LineReader
	{method} +readLine ( paramString1 : String ) : String
}


class ch.hslu.cas.msed.blobfish.game.MatchConfig {
	{method} +black () : ch.hslu.cas.msed.blobfish.player.AbstractPlayer
	{method} +equals ( paramObject1 : Object ) : boolean
	{method} +hashCode () : int
	{method} +toString () : String
	{method} +white () : ch.hslu.cas.msed.blobfish.player.AbstractPlayer
}


class ch.hslu.cas.msed.blobfish.game.OutputWriter {
	{field} ~terminal : org.jline.terminal.Terminal
	{method} +flush () : void
	{method} +print ( paramString1 : String ) : void
	{method} +printAndFlush ( paramString1 : String ) : void
	{method} +println ( paramString1 : String ) : void
	{method} +printlnAndFlush ( paramString1 : String ) : void
}


class ch.hslu.cas.msed.blobfish.game.exceptions.GameAbortedException {
}


class ch.hslu.cas.msed.blobfish.game.exceptions.MatchAbortedException {
}


class ch.hslu.cas.msed.blobfish.game.screen.HomeScreen {
	{method} +getMatchConfig () : ch.hslu.cas.msed.blobfish.game.MatchConfig
	{method} -getPlayerColor () : ch.hslu.cas.msed.blobfish.base.PlayerColor
}


class ch.hslu.cas.msed.blobfish.game.screen.MatchScreen {
	{method} -getNextMove () : String
	{method} -printPosition ( paramPlayerColor1 : ch.hslu.cas.msed.blobfish.base.PlayerColor ) : void
	{method} -shouldDisplayBoard ( paramAbstractPlayer1 : ch.hslu.cas.msed.blobfish.player.AbstractPlayer ) : boolean
	{method} +start () : void
}


abstract class ch.hslu.cas.msed.blobfish.player.AbstractPlayer {
	{method}  {abstract} +getNextMove ( paramChessBoard1 : ch.hslu.cas.msed.blobfish.board.ChessBoard ) : String
}


class ch.hslu.cas.msed.blobfish.player.HumanPlayer {
	{method} +getNextMove ( paramChessBoard1 : ch.hslu.cas.msed.blobfish.board.ChessBoard ) : String
}


abstract class ch.hslu.cas.msed.blobfish.player.bot.BotPlayer {
}


abstract class ch.hslu.cas.msed.blobfish.player.bot.minimax.MiniMaxAlgo {
	{field} -calculationDepth : int
	{method}  {abstract} +getBestNextMove ( paramChessBoard1 : ch.hslu.cas.msed.blobfish.board.ChessBoard ) : String
}


class ch.hslu.cas.msed.blobfish.player.bot.minimax.MiniMaxBotPlayer {
	{method} +getNextMove ( paramChessBoard1 : ch.hslu.cas.msed.blobfish.board.ChessBoard ) : String
}


class ch.hslu.cas.msed.blobfish.player.bot.minimax.MiniMaxSequential {
	{method} -calcBestPath ( paramChessBoard1 : ch.hslu.cas.msed.blobfish.board.ChessBoard , paramint2 : int , paramPlayerColor3 : ch.hslu.cas.msed.blobfish.base.PlayerColor , paramLinkedList4 : java.util.LinkedList ) : ch.hslu.cas.msed.blobfish.player.bot.minimax.MiniMaxSequential$ButtomNode
	{method} -copyAndAddToHistory ( paramLinkedList1 : java.util.LinkedList , paramMove2 : com.github.bhlangonijr.chesslib.move.Move ) : java.util.LinkedList
	{method} +getBestNextMove ( paramChessBoard1 : ch.hslu.cas.msed.blobfish.board.ChessBoard ) : String
	{method}  {static} -getSanOfMove ( paramMove1 : com.github.bhlangonijr.chesslib.move.Move ) : String
}


class ch.hslu.cas.msed.blobfish.player.exceptions.InvalidMoveException {
	{field} -originalMove : String
}




ch.hslu.cas.msed.blobfish.base.Piece *--  ch.hslu.cas.msed.blobfish.base.PieceType : type
ch.hslu.cas.msed.blobfish.base.Piece *--  ch.hslu.cas.msed.blobfish.base.PlayerColor : color
ch.hslu.cas.msed.blobfish.board.ui.BoardRenderer *--  ch.hslu.cas.msed.blobfish.board.ui.FieldRenderer : render
ch.hslu.cas.msed.blobfish.board.ui.ChessBoardRenderer *--  ch.hslu.cas.msed.blobfish.board.ui.BoardRenderer : boardRenderer
ch.hslu.cas.msed.blobfish.eval.MateAwareEval *--  ch.hslu.cas.msed.blobfish.eval.EvalStrategy : evalStrategy
ch.hslu.cas.msed.blobfish.eval.MateAwareEval ..|>  ch.hslu.cas.msed.blobfish.eval.EvalStrategy
ch.hslu.cas.msed.blobfish.eval.MaterialEval ..|>  ch.hslu.cas.msed.blobfish.eval.EvalStrategy
ch.hslu.cas.msed.blobfish.eval.RandomEval ..|>  ch.hslu.cas.msed.blobfish.eval.EvalStrategy
ch.hslu.cas.msed.blobfish.game.MatchConfig *--  ch.hslu.cas.msed.blobfish.player.AbstractPlayer : black
ch.hslu.cas.msed.blobfish.game.MatchConfig *--  ch.hslu.cas.msed.blobfish.player.AbstractPlayer : white
ch.hslu.cas.msed.blobfish.game.screen.HomeScreen *--  ch.hslu.cas.msed.blobfish.game.InputReader : reader
ch.hslu.cas.msed.blobfish.game.screen.HomeScreen -->  ch.hslu.cas.msed.blobfish.game.OutputWriter : writer
ch.hslu.cas.msed.blobfish.game.screen.MatchScreen -->  ch.hslu.cas.msed.blobfish.board.ChessBoard : chessboard
ch.hslu.cas.msed.blobfish.game.screen.MatchScreen -->  ch.hslu.cas.msed.blobfish.board.ui.ChessBoardRenderer : chessBoardRenderer
ch.hslu.cas.msed.blobfish.game.screen.MatchScreen -->  ch.hslu.cas.msed.blobfish.game.OutputWriter : writer
ch.hslu.cas.msed.blobfish.game.screen.MatchScreen -->  ch.hslu.cas.msed.blobfish.player.AbstractPlayer : black
ch.hslu.cas.msed.blobfish.game.screen.MatchScreen -->  ch.hslu.cas.msed.blobfish.player.AbstractPlayer : currentPlayer
ch.hslu.cas.msed.blobfish.game.screen.MatchScreen -->  ch.hslu.cas.msed.blobfish.player.AbstractPlayer : white
ch.hslu.cas.msed.blobfish.player.AbstractPlayer *--  ch.hslu.cas.msed.blobfish.base.PlayerColor : playerColor
ch.hslu.cas.msed.blobfish.player.HumanPlayer *--  ch.hslu.cas.msed.blobfish.game.InputReader : reader
ch.hslu.cas.msed.blobfish.player.HumanPlayer --|>  ch.hslu.cas.msed.blobfish.player.AbstractPlayer
ch.hslu.cas.msed.blobfish.player.bot.BotPlayer --|>  ch.hslu.cas.msed.blobfish.player.AbstractPlayer
ch.hslu.cas.msed.blobfish.player.bot.minimax.MiniMaxAlgo *--  ch.hslu.cas.msed.blobfish.base.PlayerColor : ownPlayerColor
ch.hslu.cas.msed.blobfish.player.bot.minimax.MiniMaxAlgo *--  ch.hslu.cas.msed.blobfish.eval.EvalStrategy : evalStrategy
ch.hslu.cas.msed.blobfish.player.bot.minimax.MiniMaxBotPlayer *--  ch.hslu.cas.msed.blobfish.player.bot.minimax.MiniMaxAlgo : miniMaxAlgo
ch.hslu.cas.msed.blobfish.player.bot.minimax.MiniMaxBotPlayer --|>  ch.hslu.cas.msed.blobfish.player.bot.BotPlayer
ch.hslu.cas.msed.blobfish.player.bot.minimax.MiniMaxSequential --|>  ch.hslu.cas.msed.blobfish.player.bot.minimax.MiniMaxAlgo

hide fields
hide methods

@enduml